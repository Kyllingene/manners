.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH std 3
.SH NAME
std
.SH SYNOPSIS
.br
 # \fBThe Rust Standard Library\fR
.br

.SH DESCRIPTION
The Rust Standard Library is the foundation of portable Rust software, a
set of minimal and battle\-tested shared abstractions for the broader Rust
ecosystem. It offers core types, like `Vec<T>` and
`Option<T>`, library\-defined operations on language
primitives, standard macros, I/O and
multithreading, among many other things.
.br
`std` is available to all Rust crates by default. Therefore, the
standard library can be accessed in `use` statements through the path
`std`, as in `use std::env`.
.br

.br
 # \fBHow to read this documentation\fR
.br
If you already know the name of what you are looking for, the fastest way to
find it is to use the search
bar at the top of the page.
.br
Otherwise, you may want to jump to one of these useful sections:
.br
 \- `std::*` modules
.br
 \- Primitive types
.br
 \- Standard macros
.br
 \- The Rust Prelude
.br
If this is your first time, the documentation for the standard library is
written to be casually perused. Clicking on interesting things should
generally lead you to interesting places. Still, there are important bits
you don\*(Aqt want to miss, so read on for a tour of the standard library and
its documentation!
.br
Once you are familiar with the contents of the standard library you may
begin to find the verbosity of the prose distracting. At this stage in your
development you may want to press the `[\-]` button near the top of the
page to collapse it into a more skimmable view.
.br
While you are looking at that `[\-]` button also notice the `source`
link. Rust\*(Aqs API documentation comes with the source code and you are
encouraged to read it. The standard library source is generally high
quality and a peek behind the curtains is often enlightening.
.br

.br
 # \fBWhat is in the standard library documentation?\fR
.br
First of all, The Rust Standard Library is divided into a number of focused
modules, all listed further down this page. These modules are
the bedrock upon which all of Rust is forged, and they have mighty names
like `std::slice` and `std::cmp`. Modules\*(Aq documentation typically
includes an overview of the module along with examples, and are a smart
place to start familiarizing yourself with the library.
.br
Second, implicit methods on primitive types are documented here. This can
be a source of confusion for two reasons:
.br
 1 While primitives are implemented by the compiler, the standard library
implements methods directly on the primitive types (and it is the only
library that does so), which are documented in the section on
primitives.
.br
 2 The standard library exports many modules \fIwith the same name as
primitive types\fR. These define additional items related to the primitive
type, but not the all\-important methods.
.br
So for example there is a page for the primitive type
`i32` that lists all the methods that can be called on
32\-bit integers (very useful), and there is a page for the module
`std::i32` that documents the constant values `MIN` and `MAX` (rarely
useful).
.br
Note the documentation for the primitives `str` and [`[T]`][prim@slice] (also
called \*(Aqslice\*(Aq). Many method calls on [`String`] and `Vec<T>` are actually
calls to methods on `str` and [`[T]`][prim@slice] respectively, via deref
coercions.
.br
Third, the standard library defines The Rust Prelude, a small collection
of items \- mostly traits \- that are imported into every module of every
crate. The traits in the prelude are pervasive, making the prelude
documentation a good entry point to learning about the library.
.br
And finally, the standard library exports a number of standard macros, and
lists them on this page (technically, not all of the standard
macros are defined by the standard library \- some are defined by the
compiler \- but they are documented here the same). Like the prelude, the
standard macros are imported by default into all crates.
.br

.br
 # \fBContributing changes to the documentation\fR
.br
Check out the Rust contribution guidelines here.
The source for this documentation can be found on
GitHub.
To contribute changes, make sure you read the guidelines first, then submit
pull\-requests for your suggested changes.
.br
Contributions are appreciated! If you see a part of the docs that can be
improved, submit a PR, or chat with us first on Discord
#docs.
.br

.br
 # \fBA Tour of The Rust Standard Library\fR
.br
The rest of this crate documentation is dedicated to pointing out notable
features of The Rust Standard Library.
.br

.br
 ## \fBContainers and collections\fR
.br
The [`option`] and [`result`] modules define optional and error\-handling
types, `Option<T>` and `Result<T, E>`. The [`iter`] module defines
Rust\*(Aqs iterator trait, [`Iterator`], which works with the `for` loop to
access collections.
.br
The standard library exposes three common ways to deal with contiguous
regions of memory:
.br
 \- `Vec<T>` \- A heap\-allocated \fIvector\fR that is resizable at runtime.
.br
 \- [`[T; N]`][prim@array] \- An inline \fIarray\fR with a fixed size at compile time.
.br
 \- [`[T]`][prim@slice] \- A dynamically sized \fIslice\fR into any other kind of contiguous
storage, whether heap\-allocated or not.
.br
Slices can only be handled through some kind of \fIpointer\fR, and as such come
in many flavors such as:
.br
 \- `&[T]` \- \fIshared slice\fR
.br
 \- `&mut [T]` \- \fImutable slice\fR
.br
 \- `Box<[T]>` \- \fIowned slice\fR
.br
`str`, a UTF\-8 string slice, is a primitive type, and the standard library
defines many methods for it. Rust `str`s are typically accessed as
immutable references: `&str`. Use the owned [`String`] for building and
mutating strings.
.br
For converting to strings use the [`format!`] macro, and for converting from
strings use the `FromStr` trait.
.br
Data may be shared by placing it in a reference\-counted box or the `Rc`
type, and if further contained in a `Cell` or `RefCell`, may be mutated
as well as shared. Likewise, in a concurrent setting it is common to pair an
atomically\-reference\-counted box, `Arc`, with a `Mutex` to get the same
effect.
.br
The [`collections`] module defines maps, sets, linked lists and other
typical collection types, including the common `HashMap<K, V>`.
.br

.br
 ## \fBPlatform abstractions and I/O\fR
.br
Besides basic data types, the standard library is largely concerned with
abstracting over differences in common platforms, most notably Windows and
Unix derivatives.
.br
Common types of I/O, including files, TCP, and UDP, are defined in
the [`io`], [`fs`], and [`net`] modules.
.br
The [`thread`] module contains Rust\*(Aqs threading abstractions. [`sync`]
contains further primitive shared memory types, including `atomic` and
`mpsc`, which contains the channel types for message passing.
.br

.br
 # \fBUse before and after \fR\fB`main()`\fR
.br
Many parts of the standard library are expected to work before and after `main()`;
but this is not guaranteed or ensured by tests. It is recommended that you write your own tests
and run them on each platform you wish to support.
This means that use of `std` before/after main, especially of features that interact with the
OS or global state, is exempted from stability and portability guarantees and instead only
provided on a best\-effort basis. Nevertheless bug reports are appreciated.
.br
On the other hand `core` and `alloc` are most likely to work in such environments with
the caveat that any hookable behavior such as panics, oom handling or allocators will also
depend on the compatibility of the hooks.
.br
Some features may also behave differently outside main, e.g. stdio could become unbuffered,
some panics might turn into aborts, backtraces might not get symbolicated or similar.
.br
Non\-exhaustive list of known limitations:
.br
 \- after\-main use of thread\-locals, which also affects additional features:
.br
  \- [`thread::current()`]
.br
  \- [`thread::scope()`]
.br
  \- [`sync::mpsc`]
.br
 \- before\-main stdio file descriptors are not guaranteed to be open on unix platforms
.br

.SH MODULES
mod \fIstd::prelude\fR
\fB// \fR# The Rust Prelude
.br

mod \fIstd::f32\fR
\fB// \fRConstants for the `f32` single\-precision floating point type.
.br

mod \fIstd::f64\fR
\fB// \fRConstants for the `f64` double\-precision floating point type.
.br

mod \fIstd::thread\fR
\fB// \fRNative threads.
.br

mod \fIstd::ascii\fR
\fB// \fROperations on ASCII strings and characters.
.br

mod \fIstd::backtrace\fR
\fB// \fRSupport for capturing a stack backtrace of an OS thread
.br

mod \fIstd::collections\fR
\fB// \fRCollection types.
.br

mod \fIstd::env\fR
\fB// \fRInspection and manipulation of the process\*(Aqs environment.
.br

mod \fIstd::error\fR
\fB// \fRInterfaces for working with Errors.
.br

mod \fIstd::ffi\fR
\fB// \fRUtilities related to FFI bindings.
.br

mod \fIstd::fs\fR
\fB// \fRFilesystem manipulation operations.
.br

mod \fIstd::hash\fR
\fB// \fRGeneric hashing support.
.br

mod \fIstd::io\fR
\fB// \fRTraits, helpers, and type definitions for core I/O functionali...
.br

mod \fIstd::net\fR
\fB// \fRNetworking primitives for TCP/UDP communication.
.br

mod \fIstd::num\fR
\fB// \fRAdditional functionality for numerics.
.br

mod \fIstd::os\fR
\fB// \fROS\-specific functionality.
.br

mod \fIstd::panic\fR
\fB// \fRPanic support in the standard library.
.br

mod \fIstd::path\fR
\fB// \fRCross\-platform path manipulation.
.br

mod \fIstd::process\fR
\fB// \fRA module for working with processes.
.br

mod \fIstd::sync\fR
\fB// \fRUseful synchronization primitives.
.br

mod \fIstd::time\fR
\fB// \fRTemporal quantification.
.br

mod \fIstd::simd\fR
\fB// \fRPortable SIMD module.
.br

mod \fIstd::task\fR
\fB// \fRTypes and Traits for working with asynchronous tasks.
.br

mod \fIstd::arch\fR
\fB// \fRSIMD and vendor intrinsics module.
.br

mod \fIstd::alloc\fR
\fB// \fRMemory allocation APIs.
.br

.SH MACROS
macro \fIstd::panic\fR
\fB// \fRPanics the current thread.
.br

macro \fIstd::print\fR
\fB// \fRPrints to the standard output.
.br

macro \fIstd::println\fR
\fB// \fRPrints to the standard output, with a newline.
.br

macro \fIstd::eprint\fR
\fB// \fRPrints to the standard error.
.br

macro \fIstd::eprintln\fR
\fB// \fRPrints to the standard error, with a newline.
.br

macro \fIstd::dbg\fR
\fB// \fRPrints and returns the value of a given expression for quic...
.br

macro \fIstd::thread_local\fR
\fB// \fRDeclare a new thread local storage key of type [`s...
.br

.SH PRIMITIVES
primitive \fIstd::bool\fR
\fB// \fRThe boolean type.
.br

primitive \fIstd::never\fR
\fB// \fRThe `!` type, also called "never".
.br

primitive \fIstd::char\fR
\fB// \fRA character type.
.br

primitive \fIstd::unit\fR
\fB// \fRThe `()` type, also called "unit".
.br

primitive \fIstd::pointer\fR
\fB// \fRRaw, unsafe pointers, `*const T`, and `*mut T`.
.br

primitive \fIstd::array\fR
\fB// \fRA fixed\-size array, denoted `[T; N]`, for the element...
.br

primitive \fIstd::slice\fR
\fB// \fRA dynamically\-sized view into a contiguous sequence, ...
.br

primitive \fIstd::str\fR
\fB// \fRString slices.
.br

primitive \fIstd::tuple\fR
\fB// \fRA finite heterogeneous sequence, `(T, U, ..)`.
.br

primitive \fIstd::f32\fR
\fB// \fRA 32\-bit floating point type (specifically, the "binary...
.br

primitive \fIstd::f64\fR
\fB// \fRA 64\-bit floating point type (specifically, the "binary...
.br

primitive \fIstd::i8\fR
\fB// \fRThe 8\-bit signed integer type.
.br

primitive \fIstd::i16\fR
\fB// \fRThe 16\-bit signed integer type.
.br

primitive \fIstd::i32\fR
\fB// \fRThe 32\-bit signed integer type.
.br

primitive \fIstd::i64\fR
\fB// \fRThe 64\-bit signed integer type.
.br

primitive \fIstd::i128\fR
\fB// \fRThe 128\-bit signed integer type.
.br

primitive \fIstd::u8\fR
\fB// \fRThe 8\-bit unsigned integer type.
.br

primitive \fIstd::u16\fR
\fB// \fRThe 16\-bit unsigned integer type.
.br

primitive \fIstd::u32\fR
\fB// \fRThe 32\-bit unsigned integer type.
.br

primitive \fIstd::u64\fR
\fB// \fRThe 64\-bit unsigned integer type.
.br

primitive \fIstd::u128\fR
\fB// \fRThe 128\-bit unsigned integer type.
.br

primitive \fIstd::isize\fR
\fB// \fRThe pointer\-sized signed integer type.
.br

primitive \fIstd::usize\fR
\fB// \fRThe pointer\-sized unsigned integer type.
.br

primitive \fIstd::reference\fR
\fB// \fRReferences, `&T` and `&mut T`.
.br

primitive \fIstd::fn\fR
\fB// \fRFunction pointers, like `fn(usize) \-> bool`.
.br

.SH "SEE ALSO"
alloc::slice, std::thread, core::str::traits::FromStr, alloc::vec::Vec, alloc::format, std::array, std::fs, core::i32::MAX, std::thread, std::thread::current, std::prelude, core::option, std::str, core::result, core::result::Result, std::collections, std::sync::mpsc, std::fs::File, core::option::Option, core::cell::Cell, alloc::string::String, alloc::boxed, alloc::sync::Arc, core::iter::traits::iterator::Iterator, core::i32::MIN, std::sync::mpsc, std::io, core::cell::RefCell, std::sync, core::cmp, std::net, std::i32, core::iter, std::slice, core::sync::atomic, std::io, core::i32, alloc::rc::Rc
